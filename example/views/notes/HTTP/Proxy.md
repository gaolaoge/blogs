---
title: 代理
mode: "notes"
---

> 计算机科学领域里的任何问题，都可以通过引入一个中间层来解决。

HTTP 代理属于“请求 - 应答”模型中请求方与响应方之间的中间人身份，它是可选且无需唯一的。

**代理服务**是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份：面向下游的用户时，代表源服务器响应客户端的请求；而面向上游的源服务器时，代表客户端发送请求。

这个环节做很多事情，比如：

- 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；
- 内容缓存：暂存上下行的数据，减轻后端的压力；
- 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；
- 数据处理：提供压缩、加密等额外的功能。

### 代理的作用

由于代理处在 HTTP 通信过程的中间位置，相应地就对上屏蔽了真实客户端，对下屏蔽了真实服务器。在这个中间层可以做很多的事情，为 HTTP 协议增加更多的灵活性。

**负载均衡**

因为在面向客户端时屏蔽了源服务器，客户端看到的只是代理服务器，代理服务器可以决定请求分发，由哪台服务器最终来响应请求。

代理中常用的负载均衡算法有很多，如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。

**健康检查**

使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用。

**安全防护**

保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载。

**加密卸载**

对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本。

**数据过滤**

拦截上下行的数据，任意指定策略修改请求或者响应。

**内容缓存**

在 HTTP 传输链路上，不只是客户端有缓存，服务器上的缓存也是非常有价值的，可以让请求不必走完整个后续处理流程，“就近”获得响应结果，特别是对于那些“读多写少”的数据。

源服务器系统内部虽然也经常有各种缓存（如 Memcache、Redis、Varnish 等），但 HTTP 的服务器缓存功能主要还是由代理服务器来实现（即缓存代理）。

例如突发热点新闻、爆款商品的详情页，一秒钟内可能有成千上万次的请求。即使仅仅缓存数秒钟，也能够把巨大的访问流量挡在外面，让 RPS（request per second）降低好几个数量级，减轻应用服务器的并发压力，对性能的改善是非常显著的。

代理服务收到源服务器发来的响应数据后需要做两件事。第一个是把报文转发给客户端，而第二个就是把报文存入自己的 Cache 里。

下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。

代理服务器的缓存可能会为很多客户端提供服务。所以需要对它的缓存再多一些限制条件，Cache-Control 有专门针对代理的属性。

首先，要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“private”和“public”。

- **private** 表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。
- **public** 表示缓存完全开放，谁都可以存，谁都可以用。

其次，缓存失效后的重新验证也要区分开（即使用条件请求“Last-modified”和“ETag”），

- “must-revalidate”是只要过期就必须回源服务器验证，
- “proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源。

再次，缓存的生存时间可以使用新的“s-maxage”，只限定在代理上能够存多久，而客户端仍然使用“max-age”。

还有一个代理专用的属性“no-transform”。代理有时候会对缓存下来的数据做一些优化，比如把图片转译成 png、webp 等几种格式，方便今后的请求处理，而“no-transform”就会禁止数据转译。

> 源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。

### 代理相关头字段

**Via**

代理服务器需要用字段“Via”标明代理的身份。

Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，就像是经手人盖了一个章。

如果通信链路中有很多中间代理，就会在 Via 里形成一个链表.

```http
GET / HTTP/1.1

Host: www.example.com
Via: proxy1, proxy2
```

```http
HTTP/1.1 200 OK

Via: proxy2, proxy1
```

Via 字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息。

**X-Forwarded-For 和 X-Real-IP**

X-Forwarded-For 逻辑与 Via 类似，都是用来记录请求链路的中间节点。但它记录的是数据传递所经过的所有代理的IP地址。

X-Real-IP 字段更加直接，记录的是真实的客户端IP地址。

```http
GET / HTTP/1.1

Host: www.example.com
X-Forwarded-For: 192.168.0.1:88, 192.168.0.1:89
X-Real-IP: 192.168.0.2
```
### 代理协议

有了“X-Forwarded-For”等头字段，源服务器就可以拿到准确的客户端信息了。

但对于代理服务器来说它并不是一个最佳的解决方案。因为通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。

另一个问题是“X-Forwarded-For”等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。

所以就出现了一个专门的“代理协议”（The PROXY protocol），这是一个被广泛采用的社区协议，

它在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。

首先是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。

```http
PROXY TCP4 1.1.1.1 2.2.2.2 5555 8080
GET / HTTP/1.1
Host: www.xxx.com
```

这样服务器所需要的客户端地址就显示在报文的第一行，方便实用。

### 客户端的缓存控制

客户端在 HTTP 缓存体系里要面对的是代理和源服务器，需要区别对待。

关于 Cache-Control 有两个针对缓存生存时间的属性：“max-stale”和“min-fresh”。

- **max-stale** 表示如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。
- **min-fresh** 表示返回的缓存资源至少要保持指定缓存时间范围内，新鲜期.

```http
GET / HTTP/1.1

Host: www.example.com
Cache-Control: max-stale=120
```

```http
GET / HTTP/1.1

Host: www.example.com
Cache-Control:  min-fresh=60
```

有时客户端还会配置“only-if-cached”属性，表示只接受代理缓存的数据。如果代理上没有缓存或者缓存过期，就返回 504（Gateway Timeout）。